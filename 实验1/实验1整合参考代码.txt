#include <ioCC2530.h>
/*===============IO端口定义==================*/
#define LED_RED (P1_0)     //交通灯端口定义
#define LED_GREEN (P1_1)  
#define SW1  (P1_2)     //SW1端口定义
/*=====定义公共变量--提示信息===========*/
//
char qdtx1[]="**交通灯开启\n";
char qdtx2[]="检测指示灯正常\n进入正常通行管理\n控制方式：上位机（r-正常通行，f-限行）\n系统本地（单击按键SW1在正常通行、限行间切换）";
char zlErr[]="输入指令错\n";
char jrzc[]="进入正常模式\n";
char jrcs[]="进入测试模式\n";
char jrxx[]="进入限行模式\n";
/*=====定义公共变量--系统状态记录===========*/
char oldzt=0,newzt=0;
unsigned int count_t1_IT=0,countkey=0;
unsigned char temp,RX_flag;

/*===定义延时函数：delay()-实现不精确延时===*/
void delay(int n)
{
  unsigned int j,k;
  for(k=0;k<n;k++)
    for(j=0;j<400;j++);
}
//定义系统功能函数：Test()-测试模式，Forbid()-限行模式,正常模式用定时器1定时中断控制时序
void testLed()//流水灯式点亮所有灯，测试其工作状态
{
  unsigned int i;
  for (i=0;i<5;i++)
  {      
     LED_RED =1;             //点亮LED_RED   
     delay(400);
     LED_RED =0;             //熄灭 LED_GREEN  
     delay(400);
     LED_GREEN  =1;             //点亮LED_RED   
     delay(400);
     LED_GREEN =0;             //熄灭 LED_GREEN  
     delay(400);
  }    
}
void forbid()
{
  LED_RED=1;  LED_GREEN=0; 
 }
/*=============GPIO端口初始化b====================*/
void initial_gpio()
{
  P1SEL &= ~0xFF;         //设置P1_0口和P1_2为通用I/O口
  P1DIR |= 0x03;          //设置P1_0、P1_1口为输出口            
  P1DIR &= ~0x04;         //设置P1_2口为输入口    
  P1INP &= ~0xFF;      //设置P1口所有引脚使用上拉或下拉
  P2INP |= 0x40;      //设置P1口所有引脚使用上拉
  
}
/*=====通过定时器准确定时，控制交通灯正常状态时序=====*/
void start_Timer1()
{
  LED_RED =1;             //熄灭LED_RED,LED_GREEN  
  LED_GREEN  =0;    
  count_t1_IT=0;
  T1OVFIM = 1;          //使能定时器1溢出中断
  T1IE = 1;             //使能定时器1中断
}
void stop_Timer1()
{
  T1OVFIM = 0;          //禁止定时器1溢出中断
  T1IE = 0;             //禁止定时器1中断
}
void Init_Timer1()    //定时器1初始化函数
{
  T1CC0L = 0x40;        //设置最大计数值的低8位？？
  T1CC0H = 0x9C;        //设置最大计数值的高8位
  T1CCTL0 |= 0x04;      //开启通道0的输出比较模式
  T1CTL = 0x06;         //分频系数是8,模模式
  start_Timer1();
}
/*=======定时器1中断服务实现交通灯正常控制时时序控制====*/
#pragma vector = T1_VECTOR
__interrupt void Timer1_Sevice()
{
  T1STAT &= ~0x01;      //清除定时器1通道0中断标志
  IRCON=0;
  count_t1_IT++;
  if(count_t1_IT > 1000)
  {
    count_t1_IT=0;
    LED_RED=! LED_RED;
  }
  else
  {
    if (count_t1_IT==400) LED_RED=! LED_RED;
    if ((count_t1_IT==500)||(count_t1_IT==900 )) LED_GREEN=! LED_GREEN;
  }
}

/*=======UART0建立与上位机通信，实现支持远程指令控制====*/
void initial_usart()
{
  PERCFG&=~0xFF;    //配置UART0选择位置1即采用P0的2 3 4 5 引脚
  P0SEL|=0x3C;     //配置P0的2 3 4 5 引脚为设备状态IO且为输出？？？
  P2DIR &= ~0xC0;  //
  U0GCR = 9;       //BAUD_E  波特率19200
  U0BAUD=59;       //BAUD_M
  U0UCR |= 0x80;    //禁止流控，8位数据，清除缓冲器
  U0CSR|=0x80;      //uart 模式 为发送状态
  IEN0=0x04;       //使能UART0口中断
}
void usart_tx_char(char data_tx) //定义函数收到单个字符
{
  U0DBUF = data_tx;
  while(UTX0IF==0);  //等待发送完成
  UTX0IF=0;         //清除中断标志位
  U0CSR|=0xC0; 
}
void usart_tx_string(char *data_tx,int len) //定义函数收到字符串
{
  unsigned int j;
  for(j=0;j<len;j++)
  {
    U0DBUF = *data_tx++;
    while(UTX0IF==0);  //等待发送完成
    UTX0IF=0;         //清除中断标志位
  }
  U0CSR|=0xC0; 
}
//串口中断服务函数-读取串口发来的数据，与上机位交互
#pragma vector=URX0_VECTOR
__interrupt void UART0_ISR(void)
{
  URX0IF=0;
  temp=U0DBUF;
  RX_flag=1;
  if(RX_flag == 1)
  {
    RX_flag=0;
  }
  U0CSR|=0x80;      //uart 模式 1100 0000  发使能
  if (temp!='r' && temp!='f')
  {                  
    usart_tx_string(zlErr,sizeof(zlErr));
    return ; 
  }
  oldzt=newzt;
  if (temp=='r')     newzt=0;    else      newzt=1;
  if ( oldzt!=newzt)
  {
    if (newzt==0)  //指令为切换至正常状态
    {
      usart_tx_string(jrzc,sizeof(jrzc));//指令为切换至正常状态
       start_Timer1();     //定时器启动，进入正常状态时序控制
    }
    else
    {
      usart_tx_string(jrxx,sizeof(jrxx));//指令为切换至限行状态
      stop_Timer1();     //定时器停止，停止正常指挥状态
      forbid();          //进入限行状态
    }
  }
   U0CSR|=0xC0;      //uart 模式 1100 0000  收使能
  }
/*=======采用中断检测按键状态并解析执行====*/
//中断使能函数
void initial_P1_interrupt()  
{   
  IEN2 |= 0X10;    //使能P1端口中断源
  P1IEN |= 0X04;   //使能P1.2位中断
  PICTL |= 0X02;   //P1.2中断触发方式为下降沿触发  
}

//按键式功能检测
#pragma vector = P1INT_VECTOR   //指定中断向量为P1INT_VECTOR
__interrupt void P1_ISR(void)  //定义中断服务函数--按键中断
{ 
  if(P1IF!=0x00)    //判断P1口中有中断请求产生中断
  {  
      oldzt=newzt;
      newzt=1-newzt;
      U0CSR|=0x80;      //uart 模式 1100 0000  发使能
      if (newzt==0)
        {
          usart_tx_string(jrzc,sizeof(jrzc));
          start_Timer1();
        }
        else
        {
          usart_tx_string(jrxx,sizeof(jrxx));
          stop_Timer1();
          forbid();
        }
       U0CSR|=0xC0;      //uart 模式 1100 0000  收使能
       P1IFG = 0x00;            //清除P1.2中断标志位   
    }
    P1IF = 0x00;                //清除P1端口中断标志位
}

void InterruptEn()
{
  IP1=0x14;//设置中断优先级：IP1=0x24
  IP0=0x12;//P1所在组4为第3级，UART0所有组2为2级，TIMER1所在组1为1级，其他为0级 IP1=0x22
  EA = 1;          //使能总中断  ？？串口中断使能与屏蔽处理否
}
void main()
{
  CLKCONCMD &=~0x7F;    //晶振设置为32MHz，等待晶振稳定
  while(CLKCONSTA&0x40);
  CLKCONCMD &= ~0x47;
  initial_gpio();
  Init_Timer1();
  initial_usart();
  initial_P1_interrupt();
  InterruptEn();
  U0CSR|=0x80; 
  usart_tx_string(qdtx1,sizeof(qdtx1)); //输出系统提示
  usart_tx_string(qdtx2,sizeof(qdtx2)); //输出系统提示
  testLed();
  start_Timer1();
  newzt=0;
  U0CSR|=0xC0;      //uart 模式 1100 0000  收使能
  while(1);
 }
